// Generated by CoffeeScript 1.7.1
var cryptor, cryptorKey, session, sha1, shiftKey, xorKey;

sha1 = require('./sha1');

cryptorKey = function(size, pos2) {
  this.sum = 0;
  this.key = 0;
  this.size = size;
  this.pos1 = 0;
  this.pos2 = pos2;
  this.buffer = new Uint32Array(size);
};

cryptor = (function() {
  function cryptor() {
    this.changeData = 0;
    this.changeLen = 0;
    this.keys = [new cryptorKey(55, 31), new cryptorKey(57, 50), new cryptorKey(58, 39)];
  }

  cryptor.fill = function(key) {
    var i, result, _i;
    result = new Buffer(680);
    result[0] = 128;
    for (i = _i = 1; _i < 680; i = ++_i) {
      result[i] = key[i % 128];
    }
    return result;
  };

  cryptor.prototype.generate = function(key) {
    var buffer, i, j, sha, _i, _j, _k, _l, _m;
    buffer = cryptor.fill(key);
    for (i = _i = 0; _i < 680; i = _i += 20) {
      sha = new sha1();
      sha.update(buffer);
      sha = sha.hash();
      for (j = _j = 0; _j < 20; j = _j += 4) {
        sha.copy(buffer, i + j, j, j + 4);
      }
    }
    for (i = _k = 0; _k < 55; i = ++_k) {
      this.keys[0].buffer[i] = buffer.readUInt32LE(i * 4);
    }
    for (i = _l = 0; _l < 57; i = ++_l) {
      this.keys[1].buffer[i] = buffer.readUInt32LE(i * 4 + 220);
    }
    for (i = _m = 0; _m < 58; i = ++_m) {
      this.keys[2].buffer[i] = buffer.readUInt32LE(i * 4 + 448);
    }
  };

  cryptor.prototype.apply = function(buf, size) {
    var i, j, k, keys, len, pre, remain, result, t1, t2, t3, _i, _j, _k, _l, _m, _ref;
    keys = this.keys;
    len = buf.length;
    pre = (size < this.changeLen ? size : this.changeLen);
    if (pre !== 0) {
      for (j = _i = 0; _i < pre; j = _i += 1) {
        buf[j] ^= this.changeData >>> (8 * (4 - this.changeLen + j));
      }
      this.changeLen -= pre;
      size -= pre;
    }
    for (i = _j = pre, _ref = len - 3; _j < _ref; i = _j += 4) {
      result = keys[0].key & keys[1].key | keys[2].key & (keys[0].key | keys[1].key);
      for (j = _k = 0; _k < 3; j = ++_k) {
        k = keys[j];
        if (result === k.key) {
          t1 = k.buffer[k.pos1];
          t2 = k.buffer[k.pos2];
          t3 = (t1 <= t2 ? t1 : t2);
          k.sum = ((t1 + t2) & 0xFFFFFFFF) >>> 0;
          k.key = +(t3 > k.sum);
          k.pos1 = (k.pos1 + 1) % k.size;
          k.pos2 = (k.pos2 + 1) % k.size;
        }
        buf[i] ^= k.sum;
        buf[i + 1] ^= k.sum >>> 8;
        buf[i + 2] ^= k.sum >>> 16;
        buf[i + 3] ^= k.sum >>> 24;
      }
    }
    remain = size & 3;
    if (remain !== 0) {
      result = keys[0].key & keys[1].key | keys[2].key & (keys[0].key | keys[1].key);
      this.changeData = 0;
      for (j = _l = 0; _l < 3; j = ++_l) {
        k = keys[j];
        if (result === k.key) {
          t1 = k.buffer[k.pos1];
          t2 = k.buffer[k.pos2];
          t3 = (t1 <= t2 ? t1 : t2);
          k.sum = ((t1 + t2) & 0xFFFFFFFF) >>> 0;
          k.key = +(t3 > k.sum);
          k.pos1 = (k.pos1 + 1) % k.size;
          k.pos2 = (k.pos2 + 1) % k.size;
        }
        this.changeData ^= k.sum;
      }
      for (j = _m = 0; _m < remain; j = _m += 1) {
        buf[size + pre - remain + j] ^= this.changeData >>> (j * 8);
      }
      this.changeLen = 4 - remain;
    }
  };

  return cryptor;

})();

shiftKey = function(tgt, src, n, dir) {
  var len;
  if (dir == null) {
    dir = true;
  }
  len = src.length;
  if (!dir) {
    src.copy(tgt, 0, n);
    src.copy(tgt, len - n);
  } else {
    src.copy(tgt, 0, len - n);
    src.copy(tgt, n);
  }
  return tgt;
};

xorKey = function(tgt, key1, key2) {
  var i, len, _i;
  len = Math.min(key1.length, key2.length);
  for (i = _i = 0; _i < len; i = _i += 1) {
    tgt[i] = key1[i] ^ key2[i];
  }
};

session = (function() {
  function session() {
    this.encryptor = new cryptor();
    this.decryptor = new cryptor();
    this.clientKeys = [new Buffer(128), new Buffer(128)];
    this.serverKeys = [new Buffer(128), new Buffer(128)];
  }

  session.prototype.init = function() {
    var c1, c2, s1, s2, t1, t2, _ref, _ref1;
    _ref = this.clientKeys, c1 = _ref[0], c2 = _ref[1];
    _ref1 = this.serverKeys, s1 = _ref1[0], s2 = _ref1[1];
    t1 = new Buffer(128);
    t2 = new Buffer(128);
    shiftKey(t1, s1, 31);
    xorKey(t2, t1, c1);
    shiftKey(t1, c2, 17, false);
    xorKey(t2, t1, t2);
    this.decryptor.generate(t2);
    shiftKey(t1, s2, 79);
    this.decryptor.apply(t1, 128);
    this.encryptor.generate(t1.slice(0, 128));
  };

  session.prototype.encrypt = function(data) {
    return this.encryptor.apply(data, data.length);
  };

  session.prototype.decrypt = function(data) {
    return this.decryptor.apply(data, data.length);
  };

  return session;

})();

module.exports = session;
