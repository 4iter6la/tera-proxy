// Generated by CoffeeScript 1.7.1
var Dispatch, protocol;

protocol = require('./protocol');

module.exports = Dispatch = (function() {
  function Dispatch() {
    this.connection = null;
    this.modules = {};
    this.hooks = {
      raw: {},
      pre: {}
    };
  }

  Dispatch.prototype.close = function() {
    var module, _base, _i, _len, _ref;
    _ref = this.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      module = _ref[_i];
      if (typeof (_base = module.obj).destructor === "function") {
        _base.destructor();
      }
    }
  };

  Dispatch.prototype.load = function(name, reload) {
    var e, module, path;
    if (reload == null) {
      reload = false;
    }
    try {
      if (reload) {
        path = require.resolve(name);
        delete require.cache[path];
      }
      module = require(name);
      this.modules[name] = {
        obj: new module(this),
        hooks: []
      };
      console.log("[dispatch] loaded " + name);
      return true;
    } catch (_error) {
      e = _error;
      console.error("[dispatch] load: error initializing module '" + name + "'");
      console.error(e);
      return false;
    }
  };

  Dispatch.prototype.unload = function(name) {
    var hook, module, _base, _i, _len, _ref;
    module = this.modules[name];
    if (module == null) {
      console.warn("[dispatch] unload: cannot unload non-loaded module '" + name + "'");
      return false;
    }
    if (typeof (_base = module.obj).destructor === "function") {
      _base.destructor();
    }
    _ref = module.hooks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      hook = _ref[_i];
      this.unhook.apply(this, hook);
    }
    delete this.modules[name];
    return true;
  };

  Dispatch.prototype.hook = function(name, type, cb) {
    var code, hooks;
    if (cb == null) {
      cb = type;
      type = 'pre';
    }
    if (name === '*') {
      type = 'raw';
      code = name;
    } else {
      code = protocol.map.name[name];
    }
    hooks = this.hooks[type];
    if (!hooks) {
      console.warn("[dispatch] hook: unexpected hook type '" + type + "'");
      hooks = this.hooks.pre;
    }
    if (hooks[code] == null) {
      hooks[code] = [];
    }
    return hooks[code].push(cb);
  };

  Dispatch.prototype.unhook = function(name, type, cb) {
    var code, hooks, index;
    if (cb == null) {
      cb = type;
      type = 'pre';
    }
    if (name === '*') {
      type = 'raw';
      code = name;
    } else {
      code = protocol.map.name[name];
    }
    hooks = this.hooks[type];
    if (!hooks) {
      console.warn("[dispatch] hook: unexpected hook type '" + type + "'");
      hooks = this.hooks.pre;
    }
    index = hooks[code].indexOf(cb);
    if (index === -1) {
      console.error("[dispatch] unhook: could not find cb");
      return;
    }
    return hooks[code].splice(index, 1);
  };

  Dispatch.prototype.toClient = function(name, data) {
    var e, _ref;
    if (name.constructor === Buffer) {
      data = name;
    } else {
      try {
        data = protocol.write(name, data);
      } catch (_error) {
        e = _error;
        console.error('[dispatch] failed to generate message:', name);
        console.error(e);
        console.error(data);
        return false;
      }
    }
    return (_ref = this.connection) != null ? _ref.sendClient(data) : void 0;
  };

  Dispatch.prototype.toServer = function(name, data) {
    var e, _ref;
    if (name.constructor === Buffer) {
      data = name;
    } else {
      try {
        data = protocol.write(name, data);
      } catch (_error) {
        e = _error;
        console.error('[dispatch] failed to generate message:', name);
        console.error(e);
        console.error(data);
        return false;
      }
    }
    return (_ref = this.connection) != null ? _ref.sendServer(data) : void 0;
  };

  Dispatch.prototype.handle = function(code, data, fromServer) {
    var cb, changed, event, hooks, result, _i, _j, _k, _len, _len1, _len2;
    hooks = this.hooks.raw['*'];
    if (hooks != null) {
      for (_i = 0, _len = hooks.length; _i < _len; _i++) {
        cb = hooks[_i];
        result = cb(code, data, fromServer);
        if ((result != null ? result.constructor : void 0) === Buffer) {
          data = result;
        } else if (result === false) {
          return false;
        }
      }
    }
    hooks = this.hooks.raw[code];
    if (hooks != null) {
      for (_j = 0, _len1 = hooks.length; _j < _len1; _j++) {
        cb = hooks[_j];
        result = cb(code, data, fromServer);
        if ((result != null ? result.constructor : void 0) === Buffer) {
          data = result;
        } else if (result === false) {
          return false;
        }
      }
    }
    hooks = this.hooks.pre[code];
    if (hooks != null) {
      event = protocol.parse(code, data);
      changed = false;
      for (_k = 0, _len2 = hooks.length; _k < _len2; _k++) {
        cb = hooks[_k];
        result = cb(event);
        if (result === true) {
          changed = true;
        } else if (result === false) {
          return false;
        }
      }
      if (changed) {
        data = protocol.write(code, event);
      }
    }
    return data;
  };

  return Dispatch;

})();
