// Generated by CoffeeScript 1.7.1
var fs, getLength, path, stream, _module;

fs = require('fs');

path = require('path');

stream = require('./stream');

getLength = function(message, data) {
  var element, key, length, type, _i, _j, _len, _len1, _ref, _ref1;
  length = 0;
  for (_i = 0, _len = message.length; _i < _len; _i++) {
    _ref = message[_i], key = _ref[0], type = _ref[1];
    if (typeof type === 'object') {
      _ref1 = data[key];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        element = _ref1[_j];
        length += 4 + getLength(type, element);
      }
    } else {
      switch (type) {
        case 'byte':
          length += 1;
          break;
        case 'bytes':
          length += data[key].length;
          break;
        case 'int16':
        case 'uint16':
        case 'count':
        case 'offset':
          length += 2;
          break;
        case 'int32':
        case 'uint32':
        case 'float':
          length += 4;
          break;
        case 'int64':
        case 'uint64':
        case 'double':
          length += 8;
          break;
        case 'string':
          length += (data[key].length + 1) * 2;
          break;
        default:
          console.error("unknown type " + type);
          return;
      }
    }
  }
  return length;
};

module.exports = _module = {
  map: {
    name: {},
    code: {}
  },
  messages: {},
  load: function() {
    var array, code, data, dir, file, filename, filepath, files, i, inArray, key, line, lines, map, message, messages, name, type, _, _i, _j, _k, _len, _len1, _len2, _ref;
    dir = path.join(__dirname, '../../def');
    _module.map = map = {
      name: {},
      code: {}
    };
    filename = '_map.def';
    filepath = path.join(dir, filename);
    data = fs.readFileSync(filepath, {
      encoding: 'utf8'
    });
    _ref = data.split(/\r?\n/);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      line = _ref[i];
      line = line.replace(/#.*$/, '');
      line = line.trim();
      if (line === '') {
        continue;
      }
      line = line.match(/^(\S+)\s*(\S+)$/);
      if (!line) {
        console.error("parse error: malformed line (" + filename + ":" + i + ")");
        return false;
      } else {
        _ = line[0], name = line[1], code = line[2];
        code = parseInt(code, 16);
        map.name[name] = code;
        map.code[code] = name;
      }
    }
    _module.messages = messages = {};
    files = fs.readdirSync(dir);
    for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
      file = files[_j];
      if (!(path.extname(file) === '.def' && file !== '_map.def')) {
        continue;
      }
      filepath = path.join(dir, file);
      data = fs.readFileSync(filepath, {
        encoding: 'utf8'
      });
      message = [];
      array = {
        key: null,
        members: []
      };
      name = path.basename(file, '.def');
      lines = data.split(/\r?\n/);
      for (i = _k = 0, _len2 = lines.length; _k < _len2; i = ++_k) {
        line = lines[i];
        line = line.replace(/#.*$/, '');
        line = line.trim();
        if (line === '') {
          continue;
        }
        line = line.match(/^(-?)\s*(\S+)\s*(\S+)$/);
        if (!line) {
          console.error("parse error: malformed line (" + name + ":" + i + ")");
          return false;
        } else {
          _ = line[0], inArray = line[1], type = line[2], key = line[3];
          if (inArray) {
            if (array.key == null) {
              console.error("parser error: not in array (" + name + ":" + i + ")");
              return false;
            }
            array.members.push([key, type]);
          } else {
            if (array.key != null) {
              if (array.members.length === 0) {
                console.error("parser error: empty array (" + name + ":" + i + ")");
                return false;
              }
              message.push([array.key, array.members]);
              array.key = null;
              array.members = [];
            }
            if (type === 'array') {
              if (inArray) {
                console.error("parser error: nested array (" + name + ":" + i + ")");
                return false;
              }
              array.key = key;
            } else {
              message.push([key, type]);
            }
          }
        }
      }
      if (array.key != null) {
        if (array.members.length === 0) {
          console.error("parser error: empty array (" + name + ":" + i + ")");
          return false;
        }
        message.push([array.key, array.members]);
        array.key = null;
        array.members = [];
      }
      messages[name] = message;
      if (map.name[name] == null) {
        console.warn("[protocol] unmapped message '" + name + "'");
      }
    }
    return true;
  },
  parse: function(message, reader) {
    var array, count, data, element, here, index, key, next, offset, pos, type, _i, _len, _ref;
    data = {};
    switch (typeof message) {
      case 'object':
        break;
      case 'string':
        message = _module.messages[message];
        break;
      case 'number':
        message = _module.messages[_module.map.code[message]];
        break;
      default:
        return console.error("invalid message type " + (typeof message));
    }
    if (reader.constructor === Buffer) {
      reader = new stream.readable(reader, 4);
    }
    count = {};
    offset = {};
    for (_i = 0, _len = message.length; _i < _len; _i++) {
      _ref = message[_i], key = _ref[0], type = _ref[1];
      if (typeof type === 'object') {
        array = Array(count[key]);
        next = offset[key];
        index = 0;
        while (next) {
          pos = reader.position;
          if (pos !== next) {
            console.warn("offset mismatch for array '" + key + "': expected " + next + " (at " + reader.position + ")");
            reader.seek(next);
            pos = next;
          }
          here = reader.uint16();
          if (pos !== here) {
            console.error("cannot find next element of array '" + key + "' (at " + pos + ")");
            return;
          }
          next = reader.uint16();
          element = _module.parse(type, reader);
          array[index++] = element;
        }
        data[key] = array;
      } else {
        switch (type) {
          case 'count':
            count[key] = reader.uint16();
            break;
          case 'offset':
            offset[key] = reader.uint16();
            break;
          default:
            if ((offset[key] != null) && reader.position !== offset[key]) {
              console.warn("offset mismatch for '" + key + "': expected " + offset[key] + " (at " + reader.position + ")");
              reader.seek(offset[key]);
            }
            if (type === 'bytes') {
              data[key] = reader.bytes(count[key]);
            } else {
              data[key] = reader[type]();
            }
        }
      }
    }
    return data;
  },
  write: function(message, data, writer) {
    var array, code, count, element, here, key, last, length, offset, type, _i, _j, _len, _len1, _ref;
    code = -1;
    switch (typeof message) {
      case 'object':
        break;
      case 'string':
        code = _module.map.name[message];
        message = _module.messages[message];
        break;
      case 'number':
        code = message;
        message = _module.messages[_module.map.code[message]];
        break;
      default:
        return console.error("invalid message type " + (typeof message));
    }
    if (writer == null) {
      length = 4 + getLength(message, data);
      writer = new stream.writable(length);
      writer.uint16(length);
      writer.uint16(code);
    }
    count = {};
    offset = {};
    for (_i = 0, _len = message.length; _i < _len; _i++) {
      _ref = message[_i], key = _ref[0], type = _ref[1];
      if (typeof type === 'object') {
        array = data[key];
        length = array.length;
        if (length !== 0) {
          here = writer.position;
          writer.seek(count[key]);
          writer.uint16(array.length);
          writer.seek(here);
          last = offset[key];
          for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
            element = array[_j];
            here = writer.position;
            writer.seek(last);
            writer.uint16(here);
            writer.seek(here);
            writer.uint16(here);
            last = writer.position;
            writer.uint16(0);
            _module.write(type, element, writer);
          }
        }
      } else {
        switch (type) {
          case 'count':
            count[key] = writer.position;
            writer.uint16(0);
            break;
          case 'offset':
            offset[key] = writer.position;
            writer.uint16(0);
            break;
          default:
            if (count[key] != null) {
              here = writer.position;
              writer.seek(count[key]);
              writer.uint16(data[key].length);
              writer.seek(here);
            }
            if (offset[key] != null) {
              here = writer.position;
              writer.seek(offset[key]);
              writer.uint16(here);
              writer.seek(here);
            }
            writer[type](data[key]);
        }
      }
    }
    return writer.buffer;
  }
};

_module.load();
